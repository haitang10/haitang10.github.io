<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js的作用域与声明提升]]></title>
    <url>%2F2018%2F09%2F06%2Fjs%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[js的作用域问题首先js没有块级作用域（ES6中实际上增加了这一点） 1.在es5中，js没有块级作用域，意思是函数内部可以读取全局变量，并且函数内部的变量（局部变量）可以覆盖掉全局变量的值！！这一点非常令人头疼。 看例子 var n=1 function f1(){ alert(n); } f1(); // 1 函数f1中并没有定义n 这个变量，但是还是正确输出了，为什么？因为alert(n)会先在函数内部查找1是否声明n,2是否赋值n,没有找到，自动查找外层，找到全局变量n。这就是作用域链，先在内部查找，没有的话逐步向外层寻找。 2。函数外部无法读取函数内部变量（局部变量），当然可以采用闭包的形式，这一点不难理解。 局部变量可以覆盖全局变量首先说明一点，在函数内部如果不声明变量，实际上定义的是全局变量，bb的值被改变例如 `bb = 1; function aa(cc) { bb = 2; console.log(bb); }; aa(bb); //2 console.log(bb)`//2 但是如果声明了局部变量（无论是传参数还是使用var，都声明了一个新的变量）函数运行时会在内存中新建一个名为bb的变量，函数内部的操作只对新的bb产生影响，只在函数内部有效，函数结束时变量被释放。不会影响到全局变量bb。这一点从作用域来解释是函数内的console.log() 执行的时候要先在函数内部寻找bb，发现已经声明，并且赋值，就不会再向上层去寻找了，作用域链停止在函数内。 bb = 1; function aa(bb) { bb = 2; console.log(bb); }; aa(bb); //2 console.log(bb)//1 下面的代码也是同样的效果,因为用var 声明了bb，在内存中新建了bb变量。函数内对bb的操作不会影响到全局的bb bb = 1; function aa(cc) { var bb = 2; console.log(bb); }; aa(bb);//2 console.log(bb)//1 归根到底，是js作用域链的问题。可参考https://www.bbsmax.com/A/B0zq64o3Jv/这篇文章对作用域链的理解较为深刻。 所以建议函数内部的变量都要用var来声明，并且要先声明后调用（var竟然存在变量声明提升！！！）！避免同全局变量产生冲突。 js中声明提升的问题这个问题可以参考 http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html 简单来说，就是作用域链底层的变量或函数被提升到了顶层（也可以说顶层到底层，没有关系） 变量提升 var a = 1 var f1 = function() { console.log(a) var a = 2 } f1() // undefined 首先看a的作用域链 f1&gt; global ，按理说console.log之前并没有声明a ，应该去global找，但实际上因为 var a = 2 的存在，使得a 的声明被提升，但并没有赋值，所以在f1的作用域可以找到a，只是没有赋值，所以输出undefined，所以一定要先声明后调用！！！ 用let代替var！！！ 函数声明提升看这里 https://github.com/Wscats/Good-text-Share/issues/73 经典代码 getName()//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了 var getName = function() { console.log(&apos;wscat&apos;) } //函数表达式此时才开始覆盖函数声明的定义 getName()//wscat function getName() { console.log(&apos;oaoafly&apos;) } getName()//wscat 这里就执行了函数表达式的值 // 结果是 oaoafly wscat wscat JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用 console.log(g)//undefined var g = 1; getName()//Uncaught TypeError: getName is not a function var getName = function() { console.log(&apos;wscat&apos;) } 为什么会这样？ 原因是var 声明了g这个变量，导致其提升，而var getName = function(){}并没有声明一个函数，而是把一个匿名函数赋值给了getName. 只有声明才会提升，函数表达式并未声明一个函数。 总结：Javascript中函数声明和函数表达式是存在区别的，函数声明在JS解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用。这个微小的区别，可能会导致JS代码出现意外 参考资料： https://www.bbsmax.com/A/B0zq64o3Jv/ 下一节写关于闭包的问题。。。。。头疼！！！！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[evernote]]></title>
    <url>%2F2018%2F09%2F05%2Fevernote%2F</url>
    <content type="text"><![CDATA[请输入密码啦！ Decrypt U2FsdGVkX19Tre+TxHB97M2qWKq5ASyJvSmareJzCZDumUsEreZjIJLgSdh785yaOQ6Z7lT+OkNRIDJ1uAzVGD7hsv9Hhb+gLf99Q73FydkU5nFbuPhSyuiU78WVYhSISVJkE191FnSgfhGH/hSGLdP7dd38pWlLdLQqlAmY2X5dGwSvVUNuZj16GP+XacLGVEHxXvibhJdPeoTR9viAXXr9T9HyApEM55dlCLPdd/YhWwDtyTg0h5oOWDB/EpUpplqQFaMpW95xqdQyQaRG4CZLUR5UqRhppHzT6Fu3+ujv5APy69HtmPoRL+TnU3sF5zB2PgOIL1GKWWDDiNo6yrpgEZ/b+ey4jcYqYTXkd4MJTndpCCuf5kaLHYXlc7gEZ4NH+Xwma3oL+QeEzm3bzKU//tV25AJWTRXlFl6x60FnzLlrOfYd3FbQZ0YaBWfTZ8BS/MqNsenRuOxzI+otyRX4VoF9we5EJwb1MRHpl5xjPk+yQ25eyhubdGj9jUgCB7BCO5pMLLtxRT5Th+6YPaBz3/AXfZc7P/efmu8/vwlckbT1BQBoYnhnO+DnQjf8aH4RnAhPpSsH31Kisve/BLaAd5FiZ2knwyERNL0adHEeH5ZciDMlJ5GJpbIeHZcRX61tG4/Jv5Bq6+OeoWsBBsS6cQDimMzhje03uCns5ntmbTEk/V92tiH00wUus5t/oOuACBRsWgI0vyJ/omI3gDnmz73qF6e6NWns84pfeJsG/Vk4C4Z7oKODL+l9nDlDXrK+GnqK4cCy0O6U6U/CAkxc/Mzks1J/7UyDch9CMgSRAzi4c/0Vzqzo5kA8grdus1cN7vKYipSu7TYQKI+fPbpBel9k+wyp/i/G/uoPMo2kT9/hapULsl84VitpeM0j3rLHFJbSHUE5pR0B2SebjvJCmwmcLo/Vui3A9uYpLyCyRJVrPdmQ/N7WMHDso56K]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM操作中的querySelector和getElementsby 的区别]]></title>
    <url>%2F2018%2F09%2F05%2FquerySelector%20%E5%92%8CgetElement%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[首先，什么是DOM？ DOM概述DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。每一个节点都是一个对象，有各自的属性和方法。 DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。 节点（node）DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点的类型有七种。 Document：整个文档树的顶层节点 DocumentType：doctype标签（&lt;!D`OCTYPE html&gt;`） Element：网页的各种HTML标签(&lt;body&gt;) Attribute：网页元素的属性（比如class=&quot;right&quot;） Text：标签之间或标签包含的文本 Comment：注释 DocumentFragment：文档的片段 浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。 关于node节点的详细内容如下https://wangdoc.com/javascript/dom/general.html 操作节点异同document节点对象代表整个文档，每张网页都有自己的document对象，document对象还有很多自己的属性和方法。这里我们只涉及操作节点的方法。今天讨论的两个方法有各自的优点和缺点，querySelector 方便，因为它是接受选择器作为参数，可以直接定位到要选择的元素，无需多次getElementby而后者性能更好，鱼与熊掌，不可兼得。 document.querySelector()document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 var el1 = document.querySelector(&apos;.myclass&apos;); var el2 = document.querySelector(&apos;#myParent &gt; [ng-click]&apos;); document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。这两个方法都支持复杂的 CSS 选择器。 // 选中 data-foo-bar 属性等于 someval 的元素 document.querySelectorAll(&apos;[data-foo-bar=&quot;someval&quot;]&apos;); // 选中 myForm 表单中所有不通过验证的元素 document.querySelectorAll(&apos;#myForm :invalid&apos;); // 选中div元素，那些 class 含 ignore 的除外 document.querySelectorAll(&apos;DIV:not(.ignore)&apos;); // 同时选中 div，a，script 三类元素 document.querySelectorAll(&apos;DIV, A, SCRIPT&apos;); 但是，它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。 如果querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。 最后，这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。 document.getElementsBy这个方法有 document.getElementsByTagName() document.getElementsByClassName() document.getElementsByName() document.getElementById() （只能用在document上，不能element） 不同点 querySelectorAll 返回的是一个 静态节点集合Static Node List，而 getElementsBy 系列的返回的是一个动态的集合 Live Node List。两种方法的区别就在于这个集合会不会自动更新。 x = document.querySelectorAll(&apos;img&apos;) y = document.getElementsByTagName(&apos;img&apos;) document.body.appendChild(new Image()) x.length // 0 y.length // 1 实际上getElementsBy 返回的是HTMLcollection 对象。二者区别在于NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。 var ul = document.getElementsByTagName(&apos;ul&apos;)[0], lis1 = ul.childNodes, lis2 = ul.children; console.log(lis1.toString(), lis1.length); // &quot;[object NodeList]&quot; 11 console.log(lis2.toString(), lis2.length); // &quot;[object HTMLCollection]&quot; 4 getElementBy系列的执行速度基本都是querySelectorAll的100+倍 elem.children和elem.childNodes的区别？elem.children属于html集合接口，将返回一个当前节点的所有子元素的动态的伪数组（元素节点）elem.childNodes属于NodeList接口，将分返回一个当前节点的所有子节点的伪数组（所有子节点） 参考资料： https://www.zhihu.com/question/24702250 https://wangdoc.com/javascript/dom/general.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客个性化设置]]></title>
    <url>%2F2018%2F08%2F25%2Fnext%20%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[next 主题 个性化设置参考资料 next 常见问题 http://theme-next.iissnan.com/faqs.html nMask 的博客 https://thief.one/2017/03/03/Hexo搭建博客教程/ 为NexT主题添加文章阅读量统计功能 https://notes.wanghao.work 33种个性化设置，打造炫酷网站 http://shenzekun.cn/hexo主题个性化配置教程.html 首先是主题的一些简单设定，主要是更改站点配置文件和主题配置文件，包括： 选择主题和语言 菜单项和图标 头像，选择图片路径 站点描述 添加标签和分类页面 设置字体（没有设置） 侧边栏social连接（此处有bug） 打赏功能 腾讯404页面 动画（未设置） 第三方服务 评论系统（来必力） 搜索服务（采用Local Search） 数据统计和分析，统计浏览人数和文章阅读次数 进阶内容 设置阅读全文，在文章中使用 手动进行截断， 图床（七牛云） 文章加密访问 鼠标点击小红心 异地同步博客内容 加上宠物，npm install hexo-helper-live2d 遇到的坑leancloud 无法加载leancloud 无法加载，原因是缺少security 这个安全插件，用来修复计数中存在的安全漏洞。 A plugin to fix a serious security bug in leancloud visitor counter for NexT theme site and other site that integrated this function using a similar way. 具体信息请看 GitHub文档https://github.com/theme-next/hexo-leancloud-counter-security 修复此问题见https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md 某些主题设置不会立即生效，请耐心等待几分钟！！！返回顶部按钮在屏幕尺寸小于991px时自动隐藏在移动端发现没有返回顶部按钮，调试时发现在页面宽度小于991px时，存在下列css 代码： media (min-width: 768px) and (max-width: 991px) { .back-to-top { display: none !important; } } @media (max-width: 767px) { .back-to-top { display: none !important; } } 解决办法： 在\themes\next-reloaded\source\css\_common\components中的back-to-top.styl和 back-to-top-sidebar.styl文件中删除 +tablet() { fixbutton() if hexo-config(&apos;sidebar.onmobile&apos;); hide() if not hexo-config(&apos;sidebar.onmobile&apos;); } +mobile() { fixbutton() if hexo-config(&apos;sidebar.onmobile&apos;); hide() if not hexo-config(&apos;sidebar.onmobile&apos;); } 出现这个现象的原因是在 \themes\next-reloaded\source\css\_common\scaffolding\mobile.styl 文件中存在这几行代码 &gt; 768px &amp; &lt; 991px +tablet() { } &lt; 767px +mobile() { } 导致在页面宽度小于991px时返回顶部按钮消失]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo+GitHub 搭建博客]]></title>
    <url>%2F2018%2F08%2F24%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[为什么要搭建自己的博客呢 种一棵树最好的时候是十年前，其次是现在 两个原因 想有一个属于自己的写文章的地方 身为一个程序员这还需要理由吗？ 这篇文章不是教程，只是搭建博客的过程中的一些感受，首先特别感谢吴润的知乎专栏 https://zhuanlan.zhihu.com/p/26625249 以及jmyblog 的博客http://jmyblog.top nMask’s 的博客https://thief.one 我的博客是参考了这两篇文章搭建好的，期间也遇到了很多莫名其妙的bug好在有万能的Google，在此建议想要搭建博客的同学一定要有耐心，出问题是必然的，不要担心，你遇到的坑很多人都遇到过，所以请保持一个平常心。接下来是我总结的搭建过程，比较简洁。 搭建博客步骤 获得个人网站域名（阿里云） GitHub创建个人仓库 安装Git 和 Node.js 安装Hexo 推送网站 绑定域名 个性化设置 具体的搭建过程参考上面的几篇文章，我的建议和遇到的bug是： 域名买一个简单并且便宜的，我在阿里云买了一个.top的，只要5/年。 在安装Hexo这一步，hexo init blog之后的命令都是在blog/blog这个目录下进行的，一定要注意，不能弄错了。 如果你在安装Hexo或者之前的步骤中有报错，建议你重新下载安装。因为这之前的过程全是安装的部分，一旦出错，没有别的原因，一定是你的操作有问题。而且你解决错误的时间一定要比重新安装耗费的时间长。 关于Markdown，建议用文中推荐的markdownPad2，下载后预览功能不能使用的问题需要下载awesomium插件,部分功能要升级到专业版才可以使用。 域名绑定时遇到了问题，只能采取A 记录， 映射到haitang10.github.io 的IP地址。 next主题竟然改地址了，可恶！！！ 新地址为https://github.com/theme-next，git clone https://github.com/theme-next/hexo-theme-next themes / next 个性化参考 next文档http://theme-next.iissnan.com/getting-started.html 友情链接 https://www.jianshu.com/p/0c3663c4f0ef 未完，待续]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub</tag>
        <tag>博客</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
