<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一个简单的弹幕墙]]></title>
    <url>%2F2018%2F10%2F06%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%B9%E5%B9%95%E5%A2%99%2F</url>
    <content type="text"><![CDATA[##这是一个弹幕app先用原生js实现，再用jQuery实现,最后增加云端数据保存提取功能。 预览地址：http://haitang10.top/danmu_app/ ##页面很简单，一个弹幕框，一个输入框，一个发射按钮和清屏按钮 ##要实现的功能： 1. 输入框输入内容点击发射，内容在弹幕墙出现高度随机。 2. 点击清屏，弹幕墙所有内容消失 3. 弹幕内容颜色随机，在弹幕墙的位置随机，并且向左端移动，消失。 （1.0 和 2.0 版本 弹幕从最右端出现） ##1.0 和 2.0 版本具体步骤：： 1. 给发射按钮和清屏按钮绑定事件，调用send函数和empty函数 2. send 函数把输入框内容发送到弹幕墙里面，颜色随机，高度随机。 ##3.0 版本 功能更新： 新增两个保存数据的变量，一个空数组 arry, 一个野狗云后台对象 ref.message 点击发送弹幕，就会将输入的值保存进云端对象 ref.message 里， 监听云端数据，ref.message 发生变化， 弹幕墙里的数据也发生变化。 （主要是新增弹幕） 同时后台也一直从 ref.message 中每隔一段时间随机抽取一条弹幕显示出来。 ##3.0 版本 具体步骤： 1. 新建空数组 arry 和对象 ref 2. 点击sub 按钮把数据提交到野狗云 ref.message 3. 响应键盘enter 键和 del 按钮时间，点击del 清空ref 和arr, 以及弹幕墙内容。 4. 监听云端数据变化，ref.message 新增数据节点后，获取数据，添加到arr中， 并向dm_screen 中append 弹幕内容，同时调用 moveOBj 函数，完成增加css 功能。 5. 随机从云端获取数据添加到弹幕墙。 （此功能为间接实现，在4 中，arr 和ref.message 始终保持一致。 ） //1.0版本为原生js,2.0版本为jQuery // 1,onclick and click , onclick is event,while click is a method //2, Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。// 事件通常与函数结合使用，函数不会在事件发生前被执行！// event.target 是触发事件的元素 // 键盘输入enter 触发发射按钮// w(“.s_txt”).keypress(function(event) {// if (event.keyCode == “13”) {// $(“.s_sub”).trigger(‘click’);// }// }); 参考资料：]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>野狗云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于HTML5 的移动端web 阅读器]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%9F%BA%E4%BA%8EHTML5-%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AFweb-%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预览地址：http://haitang10.top/HTML5-Web-App-Reader/ 基本功能类似于一些网站的小说页面 技术 localStorage base 64 图片 icon touch 事件 使用base64 格式的图片制作ICON优势： 可以减少请求 把图片信息放到css里面，直接加载 加快首屏数据的显示速度 缺点： 维护不方便 HTML5 新增APIDOM 操作 querySelector本地数据缓存获取位置，事件等API 性能优化: 减少repaint, reflow 尽量缓存所有可以缓存的数据 cookie localStorage 使用css3 transform 代替DOM 节点操作 animate.使用css 不要给非static 元素加 动画transform 适当使用硬件加速 移动端： 轻量化 高性能 维护简单 高性能原生 js 框架 开发过程： 页面结构搭建, 主体结构，边栏，导航栏（目录，设置，夜间） 交互 返回操作 翻页操作 设置字号和背景，同时记忆设置好的内容 存储and获取数据,又是一个闭包，把变量隐藏起来，只暴露两个方法 页面初始化时从localStorage中读取字体大小，如果没有设为14,这里需要一个全局变量，并且在点击增大减小按钮时都要修改其值 页面初始化时要从localStorage中读取背景颜色信息 实现和阅读器相关的数据交互的方法 从chapter.json获得章节列表信息 同时回调函数，通过chapter_id用于获得章节内容地址， 通过chapter_id用于获得章节内容地址这个函数自身还有一个回调，即通过jsonp请求获取真正的内容数据。 获得章节内容函数同样有回调，即渲染章节内容UI结构 总之，凡是ajax请求获取数据都有回调，回调套回调，callback hell！！！ 目录列表采用absolute 定位，点击目录时弹出。在获取章节列表信息后调用回调函数。 todo 渲染基本的UI结构 todo 交互事件绑定 轻触屏幕唤出边栏，增加结构,如果边栏被隐藏就显示，显示就隐藏两种方式，用zepto 库和原生js 原理一样，就是写法不同而已。注意jquery库无法添加addEventListener 唤出设置字体大小和背景 唤出目录 屏幕滚动 切换背景，就是一个轮播图 切换夜间模式 注意事项：1. 行内元素沿基线对齐，所以让图片居中用vertical-align 垂直对齐.bk_container{ position:relative; width: 30px; height: 30px; border-radius: 15px; background: #fff; display: inline-block; vertical-align: -14px; 2. 出现bugvar initFonSize = Utli.StorageGetter(&apos;font_size&apos;) if(!initFonSize){ initFonSize = 14 } initFonSize = parseInt(initFonSize) //设置字体大小 log(&apos;字体大小&apos;, Utli.StorageGetter(&apos;font_size&apos;)) Dom.content_size.css(&apos;font-size&apos;, initFonSize) 上述代码用函数封装之后出现bug var initFonSize = Utli.StorageGetter(&apos;font_size&apos;) var setFont = function() { if(!initFonSize){ var initFonSize = 14 } var initFonSize = parseInt(initFonSize) //设置字体大小 log(&apos;字体大小&apos;, Utli.StorageGetter(&apos;font_size&apos;)) Dom.content_size.css(&apos;font-size&apos;, initFonSize) } setFont() 出现bug 原因是在已经声明了全局变量initFonSize,所以在函数内部就不要再用var 声明变量了，这样容易声明一个局部变量，导致和全局变量冲突，无法对全局变量修改 所以全局变量声明一次就可以，因为js有作用域链，函数内部可以访问全局变量 3. 未解决bug -切换背景时点击不准确，因为把事件绑在了五个背景图的父元素上 ，父元素是一个div容器，不是精确的圆，解决办法 响应事件时判定点击的是否是五个小圆，如果点击的是圆，则 event.target.id 为真 if(event.target.id) 4. 实现和服务端数据交互，全是异步操作，回调套回调，嵌套层次很深。1.先通过ajax得到章节列表信息， 2.通过回调函数根据id获得章节内容地址，地址有jsonp字段，值为地址， 3.又一个回调函数，再通过jsonp跨域获得章节内容。 4. 再一个回调，将得到的内容用于渲染UI结构 这就导致了一个问题：代码可读性非常差，并且维护性不好。所以就有了一个问题，如何组织js异步代码？ 避免嵌套过深： 事件消息通知 ES6 Promise generator 在使用了ES6 Promise对象组织了代码后，改写 var getFictionInfoPromise = function(){ return new Promise(function(resolve, reject){ $.get(&apos;data/chapter.json&apos;,function(data){ if(data.rsult == 0){ Chapter_id = Utli.StorageGetter(&apos;last_chapter_id&apos;) if(Chapter_id == null){ Chapter_id = data.chapters[1].chapter_id } Chapter_total = data.chapters.length resolve() } else{ reject() } },&apos;json&apos;) }) } 调用的时候 var init3 = function(UIcallback){ getFictionInfoPromise().then(function(data){ return getCurChapterContentpPromise() }).then(function(data){ UIcallback &amp;&amp; UIcallback() }) } 参考资料：]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>jsonp跨域</tag>
        <tag>ES6 Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码规范]]></title>
    <url>%2F2018%2F10%2F01%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[如果声明了全局变量，那么在函数内部就不能再对其进行声明！ 代码规范之关于全局变量和局部变量今天敲代码时发现了一个bug,调试了很久一直没有解决，后来才发现是全局变量和局部变量起了冲突，本来这块之前已经写了一篇文章，http://haitang10.top/2018/09/06/js%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/#more 如果声明了全局变量，那么在函数内部就不能再声明全局变量了 首先说明一点，在函数内部如果不声明变量，实际上定义的是全局变量，bb的值被改变例如 `bb = 1; function aa(cc) { bb = 2; console.log(bb); }; aa(bb); //2 console.log(bb)`//2 但是如果声明了局部变量（无论是传参数还是使用var，都声明了一个新的变量）函数运行时会在内存中新建一个名为bb的变量，函数内部的操作只对新的bb产生影响，只在函数内部有效，函数结束时变量被释放。不会影响到全局变量bb。这一点从作用域来解释是函数内的console.log() 执行的时候要先在函数内部寻找bb，发现已经声明，并且赋值，就不会再向上层去寻找了，作用域链停止在函数内。 所以写代码时如果声明了全局变量，那么在函数内部就不能再声明全局变量了，因为这个函数目的就是对全局变量做修改 var initFonSize = Utli.StorageGetter(&apos;font_size&apos;) var setFont = function(){ if(!initFonSize){ initFonSize = 14 // 直接对全局变量做修改，不要再var } log(&apos;字体大小&apos;, initFonSize) initFonSize = parseInt(initFonSize)// 直接对全局变量做修改，不要再var log(&apos;字体大小&apos;, typeof(initFonSize),initFonSize) //设置字体大小 Dom.content_size.css(&apos;font-size&apos;, initFonSize) } setFont() 或者可以这样 参考资料：]]></content>
  </entry>
  <entry>
    <title><![CDATA[原型，原型链，继承，对象，实例]]></title>
    <url>%2F2018%2F09%2F26%2F%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[关于js 中的原型，原型链参考 https://wangdoc.com/javascript/oop/new.htmlhttps://wangdoc.com/javascript/oop/prototype.html 参考资料：]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>继承</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layout]]></title>
    <url>%2F2018%2F09%2F23%2Flayout%2F</url>
    <content type="text"><![CDATA[参考资料：]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端面试技巧与知识点整理]]></title>
    <url>%2F2018%2F09%2F19%2F%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[此文章整理自慕课网前端跳槽面试技巧 GitHub 地址 https://github.com/haitang10/FT-interview-skills FT-interview-skills1. 课程安排： 切忌浮躁！！！此仓库整理自慕课网前端跳槽面试技巧 1.1 模拟一面：面试技巧 页面布局类 CSS盒模型 DOM 事件类 HTTP 协议 原型链 面向对象 通信 前端安全 前端算法 1.2 模拟二面：面试技巧 渲染机制 js 运行机制 页面性能 错误监控 1.3 模拟三面：面试技巧 业务能力 团队协作能力 带人能力 1.4 模拟终面：面试技巧 职业竞争力 职业规划 2. 面试准备2.1 如何看待面试，面试究竟是什么？ 选拔 ？筛选？ 2.2 校招，社招的区别？ 知识，经验，能力 2.3 一面 基础知识 二面 基本原理 三面 HR 2.4 职位描述分析 (JD) 3. 一面3.1 页面布局 见 layout.html 假设高度已知，请写出三栏布局，其中左栏，右栏宽度300px,中间自适应。技术实现：float 绝对定位 grid 表格 flex 3.1.1 float 1. 左栏左浮动，固定宽度，右栏右浮动，固定宽度，中间不管。和书写顺序有关。 需要注意的是 在写HTML 的时候一定要先写left div,再写right div ，最后写center div 原因是浏览器解析HTML时按先后顺序，先写center的话因为center 默认display为block，占据一行， 接下来解析 right div 的css float right 会在下一行的右端浮动，而不是这一行！！！ 当然可以令right 部分float的margin-left 为-300 px, 2. 中间设margin-left /right,左右采用-margin float, 左面margin-left：-100% 右面 margin-left：-300 px,目的就是浮动 到上一行，HTML 书写顺序无关。 3.1.2 absolute 定位 1. 左中右全部绝对定位，左右left right 为0中间不管, position 是相对于第一个非static元素进行定位的。会脱离常规流，所以有时会覆盖元素。 这个位置并不需要为div 的父元素section 设置position reletive , 因为absolute 定位在未设置left top 等属性时是按照其原来位置进行排列的。指定了就是相对于body 详细情况见 https://www.jianshu.com/p/a3da5e27d22b 但是考虑到之后的section ，最好还是给 absolute section 增加 position relative 属性 把 article 限定在section 里面 2. 左右absolute，中间static，用margin撑开 3.1.3 flex 布局 参考 https://zhuanlan.zhihu.com/p/25303493 3.1.4 table 表格布局 3.1.5 grid 网格布局 3.1.6 几种布局方式优缺点，float 书写顺序很重要，float和absolute 都可以结合margin，二者都会脱离文档流。 去掉高度一定的话，只有flex和table可以自适应 总结： 语义化，不要总是div基础知识扎实 变通： 上下高度固定，中间自适应，两栏布局 3.2 CSS 盒模型基本概念： 标准模型 + IE 模型 二者区别 content padding border margin IE模型 宽和高包括content padding border css 设置这两种模型 box-sizing: content-box /border-box JS 设置获取盒模型对应的宽和高 dom.style.width/height 只能取到内联样式的 dom.currentStyle.width/height 取到当前的渲染之后的（只有IE 支持） window.getComputedStyle(dom).width/height 边距margin 重叠 BFC(解决重叠，清除浮动) https://zhuanlan.zhihu.com/p/25321647 https://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/ 基本概念 原理 如何创建 float值不为none position 不为static和relative table overflow不为visiable(auto,hiddion) 使用场景 3.3 DOM 事件 https://www.cnblogs.com/lvdabao/p/3265870.html https://wangdoc.com/javascript/events/model.html#%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0 https://segmentfault.com/a/1190000007082623 基本概念: 1. DOM 事件的级别 DOM 0 element.onclick = function(){} DOM 2 element.addEventListener(&apos;click&apos;, function(){}, false) element.removeEventListener(&apos;click&apos;, function(){}, false) DOM 3 element.addEventListener(&apos;keyup&apos;, function(){}, false) 在 DOM 2 的基础上新增了更多的事件类型 2. DOM 事件模型：三种 浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。JavaScript 有三种方法，可以为事件绑定监听函数。 1. DOM 0 级事件模型，事件发生后没有传播的概念，没有事件流。 事件发生，马上处理，完事，就这么简单。监听函数只是元素的一个属性值，通过指定元素的属性值来绑定监听器。书写方式有两种： HTML代码中指定属性值：&lt;input type=”button” onclick=”func1()” /&gt; 在js代码中指定属性值：document.getElementsByTagName(‘input’)[0].onclick = func1 2. IE事件模型，目标+冒泡阶段，没有捕获（IE 8 之前） 绑定监听函数attachEvent(eventType, handler) 移除 attachEvent(eventType, handler) 3. DOM 2 级事件模型 捕获阶段-目标阶段-冒泡阶段 3. DOM 事件流 DOM2 级事件规定事件流包括三个阶段 捕获阶段》目标阶段》冒泡阶段 4. 描述dom 事件捕获的具体流程 window&gt;document&gt;element(html)&gt;element(body)&gt;div 冒泡相反 5. Event 对象的常见应用 event.preventDafault() 阻止标签的默认行为，比如说 a 标签， 可以阻止它的默认跳转行为。 event.stopPropagation() 阻止事件向父级传播 阻止冒泡 event.stopImmediatePropagation() 阻止该节点所有传播 event.currentTarget 绑定监听函数的节点 event.target 当前真正点击的节点 6 自定义事件 var eve = new Event(&apos;test&apos;); //通过new Event 创建事件 ev.addEventListener(&apos;test&apos;, function () { //注册事件 console.log(&apos;test dispatch&apos;); }); setTimeout(function () { ev.dispatchEvent(eve); //触发事件 }, 1000); var eve = new CustomEvent(&apos;test&apos;) 3.4 HTTP 协议类3.4.1 HTTP 协议主要特点 无连接（连接一次就会断掉）无状态(无法区分两次连接的身份)灵活 简单快速 3.4.2 HTTP 协议报文组成 请求报文 相应报文 1，请求行或者 方法(get) 页面地址 协议版本 2，请求头 很多key-value 值，包括host, user-agent等等 Header（请求的 Header 中 Host 字段是必须的，其他都是可选） 3，\r\n\r\n（连续两个换行回车符，用来分隔Header和Body） 4，Body（可选） 相应报文 1，响应行 协议/版本(HTTP/1.1) 状态码 200 OK 2. 响应头 3，\r\n\r\n（连续两个换行回车符，用来分隔Header和Body） 4，Body（可选） 3.4.3 HTTP 协议方法 GET 获取资源 POST 传输资源 PUT 更新资源 DELETE 删除资源 HEAD 获取报文头部 3.4.4 GET POST 区别 5. get把请求的数据放在url上，即HTTP协议头上，其格式为： 以?分割URL和传输数据，参数之间以&amp;相连 数据如果是英文字母/数字，原样发送， 如果是空格，转换为+， 如果是中文/其他字符，则直接把字符串用BASE64加密，及“%”加上“字符串的16进制ASCII码”。 post把数据放在HTTP的包体内（requrest body）。 4. get 请求在url 中传送的参数有长度限制。提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）。 post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 1. GET在浏览器回退时是无害的，POST会再次提交请求。 2. GET请求会被浏览器主动cache，而POST不会，除非手动设置。 3. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求只能进行url编码，而POST支持多种编码方式。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 3.4.5 HTTP 状态码 1 指示信息- 请求已被接收，继续处理 2 成功 - 请求已被成功接收 200 OK 3 重定向 - 完成请求必须进行更进一步的操作 4 客户端错误 请求有语法错误，请求无法实现 403 访问被禁止 404 资源不存在 5 服务器错误 服务器未能实现合法的请求 3.4.6 持久连接 keep-alive https://blog.csdn.net/Misszhoudandan/article/details/80967033 HTTP 1.1 支持持久连接 非持久连接时，每个请求/ 响应客户端和服务端都要新建一个连接，完成之后立即断开连接。（HTTP 是无连接的协议） 持久连接时，使客户端到服务端的连接持续有效，当出现对服务器的后继请求时，keep-alive避免了重新建立连接 3.4.7 管线化 在持久连接的情况下，某个连接上消息的传递类似于 请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3-&gt; 管线化 将多个HTTP请求整批发送，在发送过程中不用等待对方响应 请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3-&gt; 3.5 原型链类https://wangdoc.com/javascript/oop/new.htmlhttps://wangdoc.com/javascript/oop/prototype.html 1.创建对象的几种方法 // 原型链指向Object var o1 = {name:&apos;o1&apos;} var o11 = new Object({name:&apos;o11&apos;}) // 构造函数 var M = functon(){this.name = &apos;o2&apos;} var o2 = new M() var P = {name:&apos;o3&apos;} var o3 = Object.create(P) 浏览器中输出结果 o1 {name: &quot;o1&quot;}name: &quot;o1&quot;__proto__: Object o11 {name: &quot;o11&quot;}name: &quot;o11&quot;__proto__: Object o2 M {name: &quot;o2&quot;}name: &quot;o2&quot;__proto__: Object o3 {} ###原型(prototype)构造函数 实例 原型链###object.prototype 是原型链的顶端函数才有prototype 对象没有实例对象有 proto 函数也有凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享 instanceof 的原理 new 运算符 3.6 面向对象类3.7 通信类 同源策略和限制 协议 域名 端口 任一一个不一样都是跨域 同源：同一个协议 域名 端口（默认80）） 限制：不是一个源的文档无法操控另一个源的文档，表现在 cookie localStorage indexDB 无法获取 DOM 无法获得 AJAX请求无法获得（ajax只能同源通信） 前后端如何通信 AJAX WebSocket 不受同源策略限制 CORS 支持跨域通信，也支持同源 如何创建 AJAX 跨域通信的几种方式 JSONP 就是利用&lt;script&gt;标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。 当需要通讯时，本站脚本创建一个&lt;script&gt;元素，地址指向第三方的API网址，形如： &lt;script src=&quot;http://www.example.net/api?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt; 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如: callback({&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;}) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 Hash URL里面#后面的部分 页面不刷新 search URL里面？后面的部分，页面会刷新 postMessage 跨域同于都可以 [https://blog.csdn.net/zhuzhupozhuzhuxia/article/details/76795472](https://blog.csdn.net/zhuzhupozhuzhuxia/article/details/76795472) [https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage) WebSocket 是一种网络通信协议，不受同源策略限制 http://www.ruanyifeng.com/blog/2017/05/websocket.html CORS W3C新标准，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制,目前所有浏览器都支持了http://www.ruanyifeng.com/blog/2016/04/cors.html 3.8 前端安全类https://blog.csdn.net/adrianzqt/article/details/77801635?locationNum=8&amp;fps=1 CSRF 跨站请求伪造，Cross-site request forgery 攻击原理是：A 网站某个接口存在漏洞，用户登录过A网站 防御措施： Token验证 Referer 验证 隐藏令牌 XSS 跨域脚本攻击 cross-site scripting向页面注入js代码 3.9 算法类 快排 选择 希尔参考资料：]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器中输入URL后发生了什么]]></title>
    <url>%2F2018%2F09%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[一个非常古老而又经典的问题 参考资料： https://segmentfault.com/a/1190000012092552- https://www.jianshu.com/p/c1dfc6caa520]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>浏览器渲染</tag>
        <tag>HTTP请求</tag>
        <tag>DNS服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些零碎的知识]]></title>
    <url>%2F2018%2F09%2F12%2F%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[js数组操作返回值https://wangdoc.com/javascript/stdlib/array.html push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。对空数组使用pop方法，不会报错，而是返回undefined push和pop结合使用，就构成了“后进先出”的栈结构（stack）。 shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 push和shift结合使用，就构成了“先进先出”的队列结构（queue） unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 参考资料：]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阅读列表]]></title>
    <url>%2F2018%2F09%2F11%2F%E9%98%85%E8%AF%BB%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[JavaScript 浮点数陷阱及解法 https://github.com/camsong/blog/issues/9 You-Dont-Need-jQuery https://github.com/nefe/You-Dont-Need-jQuery 排序算法时间复杂度，空间复杂度，稳定性比较 https://blog.csdn.net/yushiyi6453/article/details/76407640 无序数组排序后的最大相邻差值https://juejin.im/post/5a44acaa6fb9a0451d41c850 面试中的 10 大排序算法总结 https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md CSS绝对定位absolute详解 https://www.jianshu.com/p/a3da5e27d22b 参考资料：]]></content>
      <categories>
        <category>阅读列表</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>精确度</tag>
        <tag>浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于闭包的一些问题]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于闭包的一些特性和作用 概述可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 function f1() { var n = 999; function f2() { console.log(n); } return f2; } var result = f1(); result(); // 999 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。 几个例子function createIncrementor(start) { return function () { return start++; }; } var inc = createIncrementor(5); inc() // 5 inc() // 6 inc() // 7 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留到了全局变量中，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，而create函数的执行环境包含start，所以start变量不会被销毁，一直保存在内存中 因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 function f1() { var result = new Array() for (var i=0; i&lt;10; i++) { result[i] = function() { return i } } return result } var a = f1() var a1 = a[0] var a2 = a[1] a2() // 10 f1()[0]() // 10 f1返回一个函数数组，每个函数返回的并不是自己的索引值，而是全都是10,原因在于返回的函数引用了变量i,但它并非立刻执行。等到10个函数都返回时，它们所引用的变量i已经变成了10，因此最终结果为10返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 而如果把var 改成let function f1() { var result = new Array() for (let i=0; i&lt;10; i++) { result[i] = function() { return i } } return result } var a = f1() var a1 = a[0] var a2 = a[1] a2() // 1 f1()[0]() // 0 就不会出现问题了，原因在于let 引入块级作用域，每一次循环的i 都是不同的变量i.也就是每循环一次产生一个新的变量在内存中。 参考资料：]]></content>
      <tags>
        <tag>作用域</tag>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量，作用域，内存，闭包问题]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%8F%98%E9%87%8F%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文转载自js基础教程https://wangdoc.com/javascript/types/function.html#%E9%97%AD%E5%8C%85 #概述##函数的声明JavaScript 有三种声明函数的方法。 （1）function 命令 function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。 function print(s) { console.log(s); } 上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。 （2）函数表达式 除了用function命令声明函数，还可以采用变量赋值的写法。 var print = function(s) { console.log(s); }; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 var print = function x(){ console.log(typeof x); }; x // ReferenceError: x is not defined print() // function 上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。 var f = function f() {};需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。 （3）Function 构造函数 第三种声明函数的方式是Function构造函数。 var add = new Function( &apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos; ); // 等同于 function add(x, y) { return x + y; } 上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 var foo = new Function( &apos;return &quot;hello world&quot;;&apos; ); // 等同于 function foo() { return &apos;hello world&apos;; } Function构造函数可以不使用new命令，返回结果完全一样。 总的来说，这种声明函数的方式非常不直观，几乎无人使用。 ##函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 function f() { console.log(1); } f() // 2 function f() { console.log(2); } f() // 2 上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。 ##圆括号运算符，return 语句和递归函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。 ##第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。 由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 function add(x, y) { return x + y; } // 将函数赋值给一个变量 var operator = add; // 将函数作为参数和返回值 function a(op){ return op; } a(add)(1, 1) // 2 ##函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 f(); function f() {} 表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 f(); var f = function (){}; // TypeError: undefined is not a function 上面的代码等同于下面的形式。 var f; f(); f = function () {}; 上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 var f = function () { console.log(&apos;1&apos;); } function f() { console.log(&apos;2&apos;); } f() // 1 #函数作用域##定义作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。 函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 var v = 1; function f() { console.log(v); } f() // 1 上面的代码表明，函数f内部可以读取全局变量v。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 function f(){ var v = 1; } v // ReferenceError: v is not defined 上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 var v = 1; function f(){ var v = 2; console.log(v); } f() // 2 v // 1 上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。 注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。 if (true) { var x = 5; } console.log(x); // 5 上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。 ##函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 function foo(x) { if (x &gt; 100) { var tmp = x - 100; } } // 等同于 function foo(x) { var tmp; if (x &gt; 100) { tmp = x - 100; }; } ##函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 var a = 1; var x = function () { console.log(a); }; function f() { var a = 2; x(); } f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。 var x = function () { console.log(a); }; function y(f) { var a = 2; f(); } y(x) // ReferenceError: a is not defined 上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。 同样的，函数体内部声明的函数，作用域绑定函数体内部。 function foo() { var x = 1; function bar() { console.log(x); } return bar; } var x = 2; var f = foo(); f() // 1 上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。 #参数##概述函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。 function square(x) { return x * x; } square(2) // 4 square(3) // 9 上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。 参数的省略函数参数不是必需的，Javascript 允许省略参数。 function f(a, b) { return a; } f(1, 2, 3) // 1 f(1) // 1 f() // undefined f.length // 2 上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入 undefined。 function f(a, b) { return a; } f( , 1) // SyntaxError: Unexpected token ,(…) f(undefined, 1) // undefined 上面代码中，如果省略第一个参数，就会报错。 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 var p = 2; function f(p) { p = 3; } f(p); p // 2 上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 var obj = { p: 1 }; function f(o) { o.p = 2; } f(obj); obj.p // 2 上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 var obj = [1, 2, 3]; function f(o) { o = [2, 3, 4]; } f(obj); obj // [1, 2, 3] 上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 同名参数如果有同名的参数，则取最后出现的那个值。 function f(a, a) { console.log(a); } f(1, 2) // 2 上面代码中，函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。 function f(a, a) { console.log(a); } f(1) // undefined 调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。 function f(a, a) { console.log(arguments[0]); } f(1) // 1 ##arguments 对象（1）定义 由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 var f = function (one) { console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]); } f(1, 2, 3) // 1 // 2 // 3 正常模式下，arguments对象可以在运行时修改。 var f = function(a, b) { arguments[0] = 3; arguments[1] = 2; return a + b; } f(1, 1) // 5 上面代码中，函数f调用时传入的参数，在函数内部被修改成3和2。 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 var f = function(a, b) { &apos;use strict&apos;; // 开启严格模式 arguments[0] = 3; // 无效 arguments[1] = 2; // 无效 return a + b; } f(1, 1) // 2 上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。 function f() { return arguments.length; } f(1, 2, 3) // 3 f(1) // 1 f() // 0 （2）与数组的关系 需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。 var args = Array.prototype.slice.call(arguments); // 或者 var args = []; for (var i = 0; i &lt; arguments.length; i++) { args.push(arguments[i]); } （3）callee 属性 arguments对象带有一个callee属性，返回它所对应的原函数。 var f = function () { console.log(arguments.callee === f); } f() // true 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 #函数的其他知识点#闭包闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。 var n = 999; function f1() { console.log(n); } f1() // 999 上面代码中，函数f1可以读取全局变量n。 但是，函数外部无法读取函数内部声明的变量。 function f1() { var n = 999; } console.log(n) // Uncaught ReferenceError: n is not defined( 上面代码中，函数f1内部声明的变量n，函数外是无法读取的。 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 function f1() { var n = 999; function f2() { console.log(n); // 999 } } 上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ function f1() { var n = 999; function f2() { console.log(n); } return f2; } f1() //ƒ f2() { console.log(n); } var result = f1(); result(); // 999 f1()() //999 上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。注意，直接输入f1(),得到的是返回函数f2,并不会真正运行，需要f1()()!!!! 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。 function createIncrementor(start) { return function () { return start++; }; } var inc = createIncrementor(5); inc() // 5 inc() // 6 inc() // 7 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。 function Person(name) { var _age; function setAge(n) { _age = n; } function getAge() { return _age; } return { name: name, getAge: getAge, setAge: setAge }; } var p1 = Person(&apos;张三&apos;); p1.setAge(25); p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 立即调用的函数表达式（IIFE）在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。 function(){ /* code */ }(); // SyntaxError: Unexpected token ( 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。 // 语句 function f() {} // 表达式 var f = function f() {} 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。 (function(){ /* code */ }()); // 或者 (function(){ /* code */ })(); 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。 // 报错 (function(){ /* code */ }()) (function(){ /* code */ }()) 上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。 var i = function(){ return 10; }(); true &amp;&amp; function(){ /* code */ }(); 0, function(){ /* code */ }(); 甚至像下面这样写，也是可以的。 !function () { /* code */ }(); ~function () { /* code */ }(); -function () { /* code */ }(); +function () { /* code */ }(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 // 写法一 var tmp = newData; processData(tmp); storeData(tmp); // 写法二 (function () { var tmp = newData; processData(tmp); storeData(tmp); }()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 ##eval 命令参考资料：]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>js</tag>
        <tag>闭包</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的作用域与声明提升]]></title>
    <url>%2F2018%2F09%2F06%2Fjs%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[js的作用域问题首先js没有块级作用域（ES6中实际上增加了这一点） 1.在es5中，js没有块级作用域，意思是函数内部可以读取全局变量，并且函数内部的变量（局部变量）可以覆盖掉全局变量的值！！这一点非常令人头疼。 看例子 var n=1 function f1(){ alert(n); } f1(); // 1 函数f1中并没有定义n 这个变量，但是还是正确输出了，为什么？因为alert(n)会先在函数内部查找1是否声明n,2是否赋值n,没有找到，自动查找外层，找到全局变量n。这就是作用域链，先在内部查找，没有的话逐步向外层寻找。 2。函数外部无法读取函数内部变量（局部变量），当然可以采用闭包的形式，这一点不难理解。 局部变量可以覆盖全局变量首先说明一点，在函数内部如果不声明变量，实际上定义的是全局变量，bb的值被改变例如 `bb = 1; function aa(cc) { bb = 2; console.log(bb); }; aa(bb); //2 console.log(bb)`//2 但是如果声明了局部变量（无论是传参数还是使用var，都声明了一个新的变量）函数运行时会在内存中新建一个名为bb的变量，函数内部的操作只对新的bb产生影响，只在函数内部有效，函数结束时变量被释放。不会影响到全局变量bb。这一点从作用域来解释是函数内的console.log() 执行的时候要先在函数内部寻找bb，发现已经声明，并且赋值，就不会再向上层去寻找了，作用域链停止在函数内。 bb = 1; function aa(bb) { bb = 2; console.log(bb); }; aa(bb); //2 console.log(bb)//1 下面的代码也是同样的效果,因为用var 声明了bb，在内存中新建了bb变量。函数内对bb的操作不会影响到全局的bb bb = 1; function aa(cc) { var bb = 2; console.log(bb); }; aa(bb);//2 console.log(bb)//1 归根到底，是js作用域链的问题。可参考https://www.bbsmax.com/A/B0zq64o3Jv/这篇文章对作用域链的理解较为深刻。 所以建议函数内部的变量都要用var来声明，并且要先声明后调用（var竟然存在变量声明提升！！！）！避免同全局变量产生冲突。 js中声明提升的问题这个问题可以参考 http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html 简单来说，就是作用域链底层的变量或函数被提升到了顶层（也可以说顶层到底层，没有关系） 变量提升 var a = 1 var f1 = function() { console.log(a) var a = 2 } f1() // undefined 首先看a的作用域链 f1&gt; global ，按理说console.log之前并没有声明a ，应该去global找，但实际上因为 var a = 2 的存在，使得a 的声明被提升，但并没有赋值，所以在f1的作用域可以找到a，只是没有赋值，所以输出undefined，所以一定要先声明后调用！！！ 用let代替var！！！ 函数声明提升看这里 https://github.com/Wscats/Good-text-Share/issues/73 经典代码 getName()//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了 var getName = function() { console.log(&apos;wscat&apos;) } //函数表达式此时才开始覆盖函数声明的定义 getName()//wscat function getName() { console.log(&apos;oaoafly&apos;) } getName()//wscat 这里就执行了函数表达式的值 // 结果是 oaoafly wscat wscat JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用 console.log(g)//undefined var g = 1; getName()//Uncaught TypeError: getName is not a function var getName = function() { console.log(&apos;wscat&apos;) } 为什么会这样？ 原因是var 声明了g这个变量，导致其提升，而var getName = function(){}并没有声明一个函数，而是把一个匿名函数赋值给了getName. 只有声明才会提升，函数表达式并未声明一个函数。 总结：Javascript中函数声明和函数表达式是存在区别的，函数声明在JS解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用。这个微小的区别，可能会导致JS代码出现意外 参考资料： https://www.bbsmax.com/A/B0zq64o3Jv/ 下一节写关于闭包的问题。。。。。头疼！！！！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[evernote]]></title>
    <url>%2F2018%2F09%2F05%2Fevernote%2F</url>
    <content type="text"><![CDATA[请输入密码啦！ Decrypt U2FsdGVkX19g5icjNwQIA2sZK0acmY8BxSOLIX8tYQJzBCjOrSy/hEMK6Te/JfSVxXfnS+0jU0iZS6OJyAnBLYRUyzBdKvlXzYLI5bTmVQnE6oL7D2j0oH47gqcZ2q+g8FbvDzN7tX84D9CR7KA5v/3TgmerMjZYfr0ARnZ7M8rf9J0kqgHZmgtNqM8B2VrbXZiYBvcQ0LHT9rHL5wp3SU1Wv7EfD+M1moZz7am4f89DenkPgrgoFlT9b+PjMNItJXD6xjPIuNiJJ6+U2kHwStDlTC8RRO/PceKg/QOw3nAL2cvu7eh+EBAOxIJftEhQDEOqs/P+AM23R21vC1yYLK2JT/8WRUrJzgo6nh4+ho+2Pwur32/3fmWj2M/i8HVBxqUFmaIt8t+GrQEN0GMZIWFEueNyMhLuFEgEwZKzFdasnmVGvqibKbQbHN0yzJBZNkur4svU5CQQtFsFP4XZ3QYHjbOt+sLXUULntS0rTx3vWniJ4F/n/VxMfy9ZZmPjmIKBwLqTvZUbBGsQYCC1x40zPNZJiVGA+VzrmbLh/Kw/ddz+i7nMnI5C/Zptz+ggYM/7325pCDdfbTOP4E6PZ6Rf0OlCFKeUNxeIFDoZDPEmNzutXR0GqMYM8VO2jkXowOWW9Ulq5NDEoY+hFgk8YrzIZMBa9Iy+xRsnFmgUvYeppGtHdXihq3qvhsmcMWitejQVr+flgyg0M4mEwJeJ6KUQtW4OduFnodxRVAgrr7AEF0oLnAHL/Jj3oqZM2VgP/2wXyhN03pijGmV7aU34isqgaSs8ZFqIFzaNdGd9+UXZrKn4AfV4M7YYjJjqT8eeD4pgqzzKplLt/uSZTPDWKOvPdjAxKvunSxoRjqNcj22aSwh6VkHdSGUmRgb8SlfQ8SvkTB5X4izhaGxOZckFvCK+n30UZpoeawglQg98wdz0SdTwFbDOY88awr43hmAU]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM操作中的querySelector和getElementsby 的区别]]></title>
    <url>%2F2018%2F09%2F05%2FquerySelector%20%E5%92%8CgetElement%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[首先，什么是DOM？ DOM概述DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。每一个节点都是一个对象，有各自的属性和方法。 DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。 节点（node）DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点的类型有七种。 Document：整个文档树的顶层节点 DocumentType：doctype标签（&lt;!D`OCTYPE html&gt;`） Element：网页的各种HTML标签(&lt;body&gt;) Attribute：网页元素的属性（比如class=&quot;right&quot;） Text：标签之间或标签包含的文本 Comment：注释 DocumentFragment：文档的片段 浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。 关于node节点的详细内容如下https://wangdoc.com/javascript/dom/general.html 操作节点异同document节点对象代表整个文档，每张网页都有自己的document对象，document对象还有很多自己的属性和方法。这里我们只涉及操作节点的方法。今天讨论的两个方法有各自的优点和缺点，querySelector 方便，因为它是接受选择器作为参数，可以直接定位到要选择的元素，无需多次getElementby而后者性能更好，鱼与熊掌，不可兼得。 document.querySelector()document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 var el1 = document.querySelector(&apos;.myclass&apos;); var el2 = document.querySelector(&apos;#myParent &gt; [ng-click]&apos;); document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。这两个方法都支持复杂的 CSS 选择器。 // 选中 data-foo-bar 属性等于 someval 的元素 document.querySelectorAll(&apos;[data-foo-bar=&quot;someval&quot;]&apos;); // 选中 myForm 表单中所有不通过验证的元素 document.querySelectorAll(&apos;#myForm :invalid&apos;); // 选中div元素，那些 class 含 ignore 的除外 document.querySelectorAll(&apos;DIV:not(.ignore)&apos;); // 同时选中 div，a，script 三类元素 document.querySelectorAll(&apos;DIV, A, SCRIPT&apos;); 但是，它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。 如果querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。 最后，这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。 document.getElementsBy这个方法有 document.getElementsByTagName() document.getElementsByClassName() document.getElementsByName() document.getElementById() （只能用在document上，不能element） 不同点 querySelectorAll 返回的是一个 静态节点集合Static Node List，而 getElementsBy 系列的返回的是一个动态的集合 Live Node List。两种方法的区别就在于这个集合会不会自动更新。 x = document.querySelectorAll(&apos;img&apos;) y = document.getElementsByTagName(&apos;img&apos;) document.body.appendChild(new Image()) x.length // 0 y.length // 1 实际上getElementsBy 返回的是HTMLcollection 对象。二者区别在于NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。 var ul = document.getElementsByTagName(&apos;ul&apos;)[0], lis1 = ul.childNodes, lis2 = ul.children; console.log(lis1.toString(), lis1.length); // &quot;[object NodeList]&quot; 11 console.log(lis2.toString(), lis2.length); // &quot;[object HTMLCollection]&quot; 4 getElementBy系列的执行速度基本都是querySelectorAll的100+倍 elem.children和elem.childNodes的区别？elem.children属于html集合接口，将返回一个当前节点的所有子元素的动态的伪数组（元素节点）elem.childNodes属于NodeList接口，将分返回一个当前节点的所有子节点的伪数组（所有子节点） 参考资料： https://www.zhihu.com/question/24702250 https://wangdoc.com/javascript/dom/general.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
        <tag>querySelector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客个性化设置]]></title>
    <url>%2F2018%2F08%2F25%2Fnext%20%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[next 主题 个性化设置 参考资料 next 常见问题 http://theme-next.iissnan.com/faqs.html nMask 的博客 https://thief.one/2017/03/03/Hexo搭建博客教程/ 为NexT主题添加文章阅读量统计功能 https://notes.wanghao.work 33种个性化设置，打造炫酷网站 http://shenzekun.cn/hexo主题个性化配置教程.html 首先是主题的一些简单设定，主要是更改站点配置文件和主题配置文件，包括： 选择主题和语言 菜单项和图标 头像，选择图片路径 站点描述 添加标签和分类页面 设置字体（没有设置） 侧边栏social连接（此处有bug） 打赏功能 腾讯404页面 动画（未设置） 第三方服务 评论系统（来必力） 搜索服务（采用Local Search） 数据统计和分析，统计浏览人数和文章阅读次数 进阶内容 设置阅读全文，在文章中使用 手动进行截断， 图床（七牛云） 文章加密访问 鼠标点击小红心 异地同步博客内容 加上宠物，npm install hexo-helper-live2d 遇到的坑leancloud 无法加载leancloud 无法加载，原因是缺少security 这个安全插件，用来修复计数中存在的安全漏洞。 A plugin to fix a serious security bug in leancloud visitor counter for NexT theme site and other site that integrated this function using a similar way. 具体信息请看 GitHub文档https://github.com/theme-next/hexo-leancloud-counter-security 修复此问题见https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md 某些主题设置不会立即生效，请耐心等待几分钟！！！返回顶部按钮在屏幕尺寸小于991px时自动隐藏在移动端发现没有返回顶部按钮，调试时发现在页面宽度小于991px时，存在下列css 代码： media (min-width: 768px) and (max-width: 991px) { .back-to-top { display: none !important; } } @media (max-width: 767px) { .back-to-top { display: none !important; } } 解决办法： 在\themes\next-reloaded\source\css\_common\components中的back-to-top.styl和 back-to-top-sidebar.styl文件中删除 +tablet() { fixbutton() if hexo-config(&apos;sidebar.onmobile&apos;); hide() if not hexo-config(&apos;sidebar.onmobile&apos;); } +mobile() { fixbutton() if hexo-config(&apos;sidebar.onmobile&apos;); hide() if not hexo-config(&apos;sidebar.onmobile&apos;); } 出现这个现象的原因是在 \themes\next-reloaded\source\css\_common\scaffolding\mobile.styl 文件中存在这几行代码 &gt; 768px &amp; &lt; 991px +tablet() { } &lt; 767px +mobile() { } 导致在页面宽度小于991px时返回顶部按钮消失]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo+GitHub 搭建博客]]></title>
    <url>%2F2018%2F08%2F24%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E5%88%A9%E7%94%A8hexo%2BGitHub%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[为什么要搭建自己的博客呢 种一棵树最好的时候是十年前，其次是现在 两个原因 想有一个属于自己的写文章的地方 身为一个程序员这还需要理由吗？ 这篇文章不是教程，只是搭建博客的过程中的一些感受，首先特别感谢吴润的知乎专栏 https://zhuanlan.zhihu.com/p/26625249 以及jmyblog 的博客http://jmyblog.top nMask’s 的博客https://thief.one 我的博客是参考了这两篇文章搭建好的，期间也遇到了很多莫名其妙的bug好在有万能的Google，在此建议想要搭建博客的同学一定要有耐心，出问题是必然的，不要担心，你遇到的坑很多人都遇到过，所以请保持一个平常心。接下来是我总结的搭建过程，比较简洁。 搭建博客步骤 获得个人网站域名（阿里云） GitHub创建个人仓库 安装Git 和 Node.js 安装Hexo 推送网站 绑定域名 个性化设置 具体的搭建过程参考上面的几篇文章，我的建议和遇到的bug是： 域名买一个简单并且便宜的，我在阿里云买了一个.top的，只要5/年。 在安装Hexo这一步，hexo init blog之后的命令都是在blog/blog这个目录下进行的，一定要注意，不能弄错了。 如果你在安装Hexo或者之前的步骤中有报错，建议你重新下载安装。因为这之前的过程全是安装的部分，一旦出错，没有别的原因，一定是你的操作有问题。而且你解决错误的时间一定要比重新安装耗费的时间长。 关于Markdown，建议用文中推荐的markdownPad2，下载后预览功能不能使用的问题需要下载awesomium插件,部分功能要升级到专业版才可以使用。 域名绑定时遇到了问题，只能采取A 记录， 映射到haitang10.github.io 的IP地址。 next主题竟然改地址了，可恶！！！ 新地址为https://github.com/theme-next，git clone https://github.com/theme-next/hexo-theme-next themes / next 个性化参考 next文档http://theme-next.iissnan.com/getting-started.html 友情链接 https://www.jianshu.com/p/0c3663c4f0ef 未完，待续]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>next</tag>
        <tag>hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
